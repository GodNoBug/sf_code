package jg.tree.binary;

/**
 * 红黑树基础
 */
public class BTree {
    // B树(B-tree、B-树): Balance Tree
    // B树是一种平衡的多路搜索树,多用于文件系统、数据库的实现
    // - 一个节点可以存储超过2个元素、可以拥有超过2个子节点
    // - 拥有二叉搜索树的一些性质
    // - 平衡,每个节点的所有子树高度一致
    // - 比较矮

    // m阶B树的性质(m≥2)
    // 1.假设一个节点存储的元素个数为x
    //  - 根节点中元素个数: 1 ≤ x ≤ m-1
    //  - 非根节点中元素个数: ⌈m/2⌉ -1  ≤ x ≤ m-1    [为向上取整]

    //  - 如果有子节点,子节点个数y=x+1
    //    -- 根节点的子节点个数: 2≤ y ≤ m
    //    -- 非根节点的子节点个数 ⌈m/2⌉≤ y ≤ m
    //  比如 m=3, 2≤ y ≤ 3 ,因此可以称为(2,3)树,2-3树.
    //  比如 m=4, 2≤ y ≤ 4 ,因此可以称为(2,4)树,2-3-4树.
    //  比如 m=5, 3≤ y ≤ 5 ,因此可以称为(3,5)树,3-4-5树.
    //  m=2就是二叉搜索树


    // B树和二叉搜索树联系
    // 在逻辑上是等价的
    // 二叉搜索树多代合并,可以获得一个超级节点
    //  -- 2代合并的超级节点,超级节点最多拥有4个节点(至少是4阶B树) [二叉树第一代有1个元素,第二代有两个元素,第二代的子节点最多有4个子节点,2代合并成一个节点,有3个元素合并在一起,那么最多有4个子节点]
    //  -- 3代合并的超级节点,超级节点最多拥有8个节点(至少是8阶B树)
    //  -- n代合并的超级节点,超级节点最多拥有2^n个节点(至少是2^n阶B树)


    // 搜索
    // 1.先在节点内部从小到大开始搜索元素
    // 2.如果命中,搜索结束
    // 3.如果未命中,再去对应的子节点中搜索元素,重复步骤1


    // 添加
    // 1.新添加的元素必定 是添加到叶子节点 [重要,红黑树有用]
    // 2.叶子节点元素超过限制,这种现象称为上溢(overflow)

    // 上溢的解决
    // 上溢节点的元素个数必然等于m
    // 假设上溢节点最中间元素的位置为k
    // 1.将k位置的元素向上与父节点合并
    // 2.将[0,k-1]和[k+1,m-1]位置元素分裂成2个子节点 [这2个子节点元素的个数必然不会低于最低限制(⌈m/2⌉-1)]
    // 3.一次分裂完毕后,有可能导致父节点上溢,依然按照上述方法解决 [最极端的情况,有可能一直分裂到根节点]
    // 上溢达到根节点是唯一让B树长高的情况

    // 删除
    // 1.假如需要删除的元素再叶子节点中,那么直接删除即可
    // 2.假如需要删除的元素再非叶子节点中
    //   - 先找到前驱或后续元素,覆盖所需删除元素的值
    //   - 再把前驱或后继元素删除
    // 在B树中,非叶子节点的前序或后续元素,必定在叶子节点中.真正被删除的还是叶子节点的东西
    // 所以这里的删除前驱或后续元素,就是最开始提到的情况:删除的元素在叶子节点中
    // 真正的删除元素都是发生在叶子节点中 [重要,红黑树有用]

    // 下溢的解决
    // 叶子节点被删除一个元素后,元素个数可能会低于最低限制(≥⌈m/2⌉ -1),这种现象称为"下溢(underflow)"
    // 下溢的节点数量必然等于⌈m/2⌉-2                 就触发
    // 如果下溢的节点临近的兄弟节点,至少⌈m/2⌉个元素,可以向其借一个元素    (兄弟节点依然不会低于限制)
    // 1.将父节点的元素b插入到下溢节点的0位置(最小位置)
    // 2.(不能直接将兄弟节点"借"过来,否则破坏了"大小"性质)
    // 3.用兄弟节点的元素a(最大的元素)替代父节点的b.
    // 这种操作其实就是:旋转 如下图
    //                 b                                              a
    //            /         \                                    /         \
    //   (≥⌈m/2⌉) a          ⌈m/2⌉-2                        (≥⌈m/2⌉)-1      b ⌈m/2⌉-1
    //             \                                                         /
    //              d                                                       d
    // 如果下溢节点临近的兄弟节点只有≥⌈m/2⌉-1个元素(没法借了)
    // 将父节点的元素b挪下来跟左右子节点进行合并
    // 合并后的节点元素个数等于⌈m/2⌉+⌈m/2⌉-2,不超过m-1
    //              a b  c                                         a c
    //            /         \                                        \
    //   (≥⌈m/2⌉-1) a        ⌈m/2⌉-2                     (≥⌈m/2⌉)-1   b   b ⌈m/2⌉-2
    // 这个操作可能会导致父节点下溢,依然按照上述方法解决,下溢现象可能会一直往上传播
    // 下溢到根节点是唯一让B树变矮的情况


    // 4阶B树
    // 如果先学习4阶B树(2-3-4树),将能更好的学习红黑树

    // 4阶B树的性质
    // 所有节点能存储的元素个数:x : 1≤x≤3
    // 所有非叶子节点的子节点个数: y: 2≤y≤4

    // TODO 添加/删除
    //  从1添加/删除到22 画图


    // 红黑树的等价变换
    // 1.红黑树和4阶B树(2-3-4树)具有等价性
    // 2.BLACK节点与它的RED子节点融合在一起,形成1个B树节点
    // 红黑树的BLACK节点个数与4阶B树的节点总个数相等,在B树节点中,BLACK节点永远是父节点
    // 网上有些用2-3树与红黑树进行类比,是极其不严谨的,2-3树并不能完美匹配红黑树的所有情况
    // 注意: 为省事儿,一般展示红黑树都会省略NULL节点

    //       红黑红              黑红               红黑             黑
    //         B                 B                  B               B
    //       /   \             /   \              /   \           /   \
    //      R     R           B     R            R     B         B     B
    //     / \   / \               / \          / \
    //    B   B B   B             B   B        B   B
    //                          ↓
    //       R-B-R             B-R                  R-B             B
    //      / | | \           / | \                / | \          /   \   (黑情况是一个独立的B树节点)
    //     B  B B  B         B  B  B              B  B  B        B     B
    // 思考: 如果上图最底层的BLACK节点是不存在的,在B树中是什么情形? 整颗B树只有1个节点,而且是超级节点
}