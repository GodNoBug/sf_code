package jg.graph.graph2;


import jg.graph.VertexVisitor;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 邻接矩阵:(适合稠密图,边比较多才能把素组充分利用起来,)
 * -用一维数组存放顶点信息
 * -用二维数组存放边信息:边和边的排列组合,交叉点的值就是权值,无穷大代表没有边.无权值可以用1,0表示存在边与否
 * 邻接表:
 * - 顶点信息有next  TODO
 */
public interface Graph<V, E> {
    // 获取顶点/边大小
    int verticesSize();

    int edgesSize();

    // 添加顶点/边
    void addVertex(V v);

    void addEdge(V from, V to);

    void addEdge(V from, V to, E weight);

    // 删除顶点/边
    void removeVertex(V v);

    void removeEdge(V from, V to);

    // 广度优先算法
    void bfs(V begin, VertexVisitor<V> visitor);

    // 深度优先算法
    void dfs(V begin, VertexVisitor<V> visitor);

    // 深度优先算法(非递归)
    void dfs2(V begin, VertexVisitor<V> visitor);

    // 度的结算

    // 生成树: 所有顶点均由边连接在一起,但不存在回路的图


    // 有向无环图
    //  - 有向无环图常用来描述一个工程或系统的进行过程.(通常把计划/施工/生产/程序流程等当成是一个工程)
    //  - 一个工程可以分为若干个子工程,只要完成了这些子工程(活动),就可以导致整个工程的完成.
    //  - 表示方法 AOV网和AOE网
    // AOV网:
    //   用一个有向图表示一个工程的各个子工程及其相互制约的关系,其中以顶点表示活动,弧表示活动之间的优先制
    // 约关系,称这种有向图为顶点表示活动的网,简称AOV网(Activity On Vertex network)
    // AOE网:
    //
    //          C
    //        ↗ ↘
    //  A -> B ->  E -> F
    //        ↘ ↗
    //          D
    // AOV网必须是一个有向无环图,因为有向有环图形成环会循环依赖
    // ◼ 前驱活动：有向边起点的活动称为终点的前驱活动
    //     只有当一个活动的前驱全部都完成后，这个活动才能进行
    // ◼ 后继活动：有向边终点的活动称为起点的后继活动

    // ◼ 什么是拓扑排序？
    //    将 AOV 网中所有活动排成一个序列，使得每个活动的前驱活动都排在该活动的前面
    //    比如上图的拓扑排序结果是： A、B、C、D、E、F 或者 A、B、D、C、E、F (结果并不一定是唯一)
    //   排完的序列恰好能够挨个顺序执行完

    // 拓扑排序-思路
    //◼ 可以使用卡恩算法(Kahn于1962年提出)完成拓扑排序
    //假设 L 是存放拓扑排序结果的列表
    //  1.把所有入度为0的顶点放入L中，然后把这些顶点从图中去掉(不可持续,需要变通)
    //  2.重复操作1，直到找不到入度为0的顶点
    //   - 如果此时L中的元素个数和顶点总数相同，说明拓扑排序完成
    //   - 如果此时L中的元素个数少于顶点总数，说明原图中存在环，无法进行拓扑排序
    List<V> topologicalSort();

    /*--------------------------------------------------生成树----------------------------------------------------------*/

    // 生成树(Spanning Tree) 也称支撑树: 所有顶点均由边连接在一起,但不存在回路的图.
    // - 一个图可以有许多棵不同的生成树,
    // - 所有生成树具有以下共同特点:
    //   -- 生成树的顶点个数与图的顶点个数相同;
    //   -- 生成树是图的极小连通子图,去掉一条边则非连通;(边不能多不能少,少了就顶点不能连通,多了就会出现回路)
    //   -- 一个有n个顶点的连通图的生成树,有n–1条边;(但含n个顶点n-1条边的图不一定是生成树)
    //   -- 在生成树中再加一条必然形成回路;
    //   -- 生成树中任意两个顶点间的路径是唯一的;
    //无向图的生成树
    // 设图G=(V,E)是个连通图,当从图任一顶点出发遍历图G时,将边集E(G)分成两个集合T(G)和B(G).其中T(G)是遍历图时所经过的边的集合,B(G)是
    // 遍历图时未经过的边的集合.显然,G1(V,T)是图G的极小连通子图.即子图G1是连通图G的生成树

    // 最小生成树 (Minimum Spanning Tree)最小支撑树
    // -给定一个无向网络,在该网的所有生成树中,使得各边权值之和最小的那颗生成树称为该网的最小生成树,也叫最小代价生成树
    // 如果图的每一条边的权值都互不相同，那么最小生成树将只有一个，否则可能会有多个最小生成树

    // 构造最小生成树 Minimum Spanning Tree
    // 构造最小生成树的算法很多,其中多数算法利用了MST性质.
    // MST性质: (性质证明要学习图论后推导)
    //    设N =(V,E) 是一个连通网, U是顶点集V的一个非空子集.
    //    若边(u,v)是一条具有最小权值的边,其中u∈V-U,则必存在一颗包含边(u,v)的最小生成树(一定包含在最小生成树里头)
    // MST性质解释:
    //    在生成树的构造过程中,图中n个顶点分属两个集合:
    //      1.已落在生成树上的顶点集U
    //      2.尚未落在生成树上的顶点集: V-U
    //    接下来则应在所有连通U中顶点和V-U中顶点的边选取权值最小的边.

    // 构造最小生成树具体方法

    //  Prim (普里姆算法)
    // 算法思想:
    //  1.设N=(V,E)是连通网,TE是N上最小生成树的边的集合;
    //  2.初始令U={u0},(u0∈V),TE={};
    //  3.在所有u∈U,v∈V-U的边(u,v)∈E中,找一条代价最小的边(u0,v0);
    //  4.将(u0,v0)并入集合TE,同时v0并入U.
    //  5.重复上述操作直至U=V位置,则T=(V,TE)为N的最小生成树
    // 总结: 每次从剩下的集合中找一个顶点,顶点的特点[到该顶点的权值最小]

    //  Kruskal(克鲁斯克尔算法)
    //
    // 算法思想: 一种贪心算法
    //   1.设连通网N=(V,E),令最小生成树初始状态为只有n个顶点而无边的非连通图T=(V,{}),每个顶点自成一个连通分量
    //   2.在E中选取代价最小的边,若该边依附的顶点落在T中不同的连通分量上(即:不能形成环),则将此边加入到T中;
    //     否则,舍去此边,选取下一条代价最小的边
    //   3.以此类推,直至T中所有顶点都在同一连通分量上为止

    // 两种算法比较
    // 算法名称   |Prim               |Kruskal         |
    // 算法思想   |选择点             |选择边           |
    // 时间复杂度 |O(n^2)(n为顶点数)   |O(eloge)(e为边数)|
    // 适应范围   |稠密图             |稀疏图            |


    // 切分定理
    // 切分(cut): 把图中的节点分为两部分,称为一个切分
    // 横切边(Crossing Edge): 如果一个边的两个顶点,分别属于切分的两个部分,这个边称为横切边
    // 切分定理: 给定任意切分,横切边中权值最小的边必然属于最小生成树的边(切分了连起来最少需要一条线就可以连起来,如果只需要一条,那么最小的生成树,那么必然是选择权值最小的)
    Set<EdgeInfo<V, E>> mst();

    @Getter
    @Setter
    @ToString
    public static class EdgeInfo<V, E> {
        private V from;
        private V to;
        private E weight;

        public EdgeInfo(V from, V to, E weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }

    public interface WeightManager<E> {
        int compare(E w1, E w2);

        E add(E w1, E w2);

    }
    /*-----------------------------------------------------最短路径----------------------------------------------------*/
    // 最短路径
    // 在有向网中A点(源点)到达B点(终点)的多条路径中,寻找一条各边权值之和最小的路径,即最短路径(有向图、无向图均适用，不能有负权环)
    //  无权图相当于是全部边权值为1的有权图
    //  有负权边, 但没有负权环时, 存在最短路径
    //  有负权环时, 不存在最短路径. 通过负权环, A到E的路径可以无限短
    // [最短路径与最小生成树不同,路径上不一定包含n个顶点,也不一定包含n-1条边]

    // 最短路径有两类问题
    //  单源最短路径算法(两点间最短路径)
    //  ✓ Dijkstra (迪杰斯特拉算法)
    //  ✓ Bellman-Ford(贝尔曼-福特算法)
    //  多源最短路径算法(某源点到其他各顶点最短路径)
    //  ✓ Floyd(弗洛伊德算法)

    //Dijkstra
    //◼ Dijkstra 属于单源最短路径算法，用于计算一个顶点到其他所有顶点的最短路径
    // 使用前提：不能有负权边(负权边有最短路径,但是不能用在Dijkstra)
    //时间复杂度：可优化至 O(ElogV) , E 是边数量， V 是节点数量

    // Dijkstra的等价思考
    // 把图想象成是用石头为顶点连起来的.放在水平桌面上选择一个石头慢慢地往上提.路径越短越早被提起.最后绷直的绳子就是顶点到某点的最短路径(注意: 有绷直的绳子和松垮的)
    // 关键: 后离开的小石头都是被先离开桌面的小石头拉起来的

    // Dijkstra的执行过程
    //  松弛操作
    Map<V,E> shortestPath(V begin);


}
// 回路
// 连通图 : 任意两个顶点都是想通的称为连通图
// 强连通子图: 有向图中任意2个顶点都是相通的称为强连通图
// 连通分量: 无向图的极大连通子图, 连通图只有一个连通分量,即其自身;非连通的无向图有多个连通分量
// 强连通分量: 有向图的极大连通子图, 强连通图只有一个连通分量,即其自身;非连通的有向图有多个强连通分量


// 图的概念
// 图(Graph) G =(V,E)
//  V: 顶点(Vertex/Vertices)的有穷非空集合
//  E: 边的有穷集合
// 有向图/无向图: 每条边都是有/无方向的
// 完全图: 任意两个点都有一条边相连.包含有向完全图和无向完全图
//          无向完全图: n个顶点,n(n-1)/2 条边
//          有向完全图: n个顶点,n(n-1)条边
// 顶点的"邻接": 如果两个点之间有一条边,那么说两个点是邻接的
//        有边/弧相连的两个顶点之间的关系
//        存在(Vi,Vj),则称Vi和Vj互为邻接点;
//        存在<Vi,Vj>,则称Vi邻接到Vj,Vj邻接与Vi
// 关联(依附):边/弧与顶点之间的关系.存在(Vi,Vj)或<Vi,Vj>,则称该边/弧关联与Vi和Vj
// 顶点的度: 与该顶点相关联的边的数目,记为TD(v)
//         在有向图中,顶点的度大于该顶点的入度和出度之和.
//         顶点 v的入度是以v为终点的有向边条数,记作ID(v)
//         顶点 v的出度是以v为终点的有向边条数,记作OD(v)
// 稀疏图: 有很少边或弧的图(e<n*logn)
// 浓密图: 有较多边或弧的图
// 网:    边/弧带权的图
// 问: 当有向图中仅1个顶点的入度都为0,其余顶点的入度都均为1,此时是何形状? 答案:树,而且是一颗有向树

// 图的表示方式
// 1.二维数组表示(邻接矩阵)
// 2.链表表示(邻接)

// 邻接矩阵:是标识图形中顶点相邻关系的矩阵,对于n个顶点的图而言,矩阵是row和col表示的是1...n个点.
//   对于每条边(u,v),设置arr[u][v]=权
// 链接表:
//   1) 链接矩阵需要为每一个顶点分配n个边的空间,其实有很多边都是不存在,会造成空间的一定损失
//   2) 链接的实现只关心存在的边,不关心不存在的边.因此没有空间浪费,邻接表由数组+链表组成
//      数组位:顶点
//      数组下挂链表:链表表示能连接的地方
// 图的概念
// 图(Graph) G =(V,E)
//  V: 顶点(Vertex/Vertices)的有穷非空集合
//  E: 边(edge)的有穷集合

// 4种最重要的图模型:
//     无向图(简单连接)、有向图(连接有方向性)、加权图(连接带有权值)和加权有向图(连接既有方向性又带有权值)。
// 有向图/无向图: 每条边都是有/无方向的
// 完全图: 任意两个点都有一条边相连.包含有向完全图和无向完全图
//          无向完全图: n个顶点,n(n-1)/2 条边
//          有向完全图: n个顶点,n(n-1)条边
// 顶点的"邻接": 如果两个点之间有一条边,那么说两个点是邻接的
//        有边/弧相连的两个顶点之间的关系
//        存在(Vi,Vj),则称Vi和Vj互为邻接点;
//        存在<Vi,Vj>,则称Vi邻接到Vj,Vj邻接与Vi
// 关联(依附):边/弧与顶点之间的关系.存在(Vi,Vj)或<Vi,Vj>,则称该边/弧关联与Vi和Vj
// 顶点的度: 与该顶点相关联的边的数目,记为TD(v)
//         在有向图中,顶点的度大于该顶点的入度和出度之和.
//         顶点 v的入度是以v为终点的有向边条数,记作ID(v)
//         顶点 v的出度是以v为终点的有向边条数,记作OD(v)
// 稀疏图: 有很少边或弧的图(e<n*logn)
// 浓密图: 有较多边或弧的图
// 网:    边/弧带权的图
// 问: 当有向图中仅1个顶点的入度都为0,其余顶点的入度都均为1,此时是何形状? 答案:树,而且是一颗有向树

// 图的表示方式
// 1.二维数组表示(邻接矩阵)
// 2.链表表示(邻接)

// 邻接矩阵:是标识图形中顶点相邻关系的矩阵,对于n个顶点的图而言,矩阵是row和col表示的是1...n个点.
//   对于每条边(u,v),设置arr[u][v]=权
// 链接表:
//   1) 链接矩阵需要为每一个顶点分配n个边的空间,其实有很多边都是不存在,会造成空间的一定损失
//   2) 链接的实现只关心存在的边,不关心不存在的边.因此没有空间浪费,邻接表由数组+链表组成
//      数组位:顶点
//      数组下挂链表:链表表示能连接的地方

