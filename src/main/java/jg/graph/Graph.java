package jg.graph;

import jg.linear_list.List;

// 邻接表和邻接矩阵的关系
// 联系: 邻接表中每一个链表对应于邻接矩阵中的一行,链表中结点个数等于一行中非零元素的个数
// 区别: 1.对于任一确定的无向图,邻接矩阵是唯一的(行列号与顶点编号一致),但邻接表不唯一(链接次序与顶点编号无关)
//       2. 邻接矩阵的空间复杂度为O(n^2),而邻接表的空间复杂度为O(n+e)
// 用途: 邻接矩阵多用于稠密图;而邻接表多用于稀疏图
public interface Graph<V, E> {
    // 图的遍历
    // 从已给的连通图中某一点出发,沿着一些边访遍图中所有的顶点,且使每个顶点仅被访问一次,就叫做图的遍历,它是图的基本运算
    // 遍历的实质: 找到每个顶点的邻接点

    // 细节:图的特点
    // 图中可能存在回路,且图的任一顶点都可能与其他顶点想通,在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点.
    //  解决思路: 设置辅助数组visited[n],用来标记每个被访问过的顶点
    //           - 初始状态visited[i]为0
    //           - 顶点i被访问,改visited[i]为1.防止被多次访问

    // 图的遍历

    // 深度优先搜索(Depth_First Search-DFS)
    //   1.每次访问过一个结点,发现有n个结点可访问,只选择一个结点访问.
    //   2.访问到无下一节点可访问的话,回退上一个位置.重复1的步骤
    // 总结: 一条道走到黑,没有路往回退,退到有路继续走,直到走完所有点

    // 方法:
    // - 在访问图中某一起始顶点V后,由V出发,访问它的任一邻接顶点W1;
    // - 再从W1出发,访问与W1邻接但还未被访问过的顶点W2;
    // - 然后再从W2出发,进行类似的访问,...
    // - 如此进行下去,直至到达所有的邻接顶点都被访问过的顶点u为止.
    // - 接着,退回一步,退到前一次刚访问过的顶点,看是否还有其他没有被访问的邻接节点.
    //  -- 如果有,则访问此顶点,之后再从此顶点出发,进行与前述类似的访问;
    //  -- 如果没有,则就再退回一步进行搜索.重复上述过程,直到连通图中的所有顶点都被访问过为止

    // 如何转化成代码

    // 连通图的深度优先遍历类似于树的先序遍历
    public void dfs(V begin, VertexVisitor<V> visitor);

    // 广度优先搜索(Breadth_First Search-BFS)
    // 方法:
    //  从图的某一结点出发,首先依次访问该节点的所有邻接顶点Vi1,Vi2,Vi3,...Vin
    //  再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点
    //  重复如此过程,直至所有顶点均被访为止


    void bfs(V begin, VertexVisitor<V> visitor);



    // 度的结算

    // 生成树: 所有顶点均由边连接在一起,但不存在回路的图


    // 有向无环图
    //  - 有向无环图常用来描述一个工程或系统的进行过程.(通常把计划/施工/生产/程序流程等当成是一个工程)
    //  - 一个工程可以分为若干个子工程,只要完成了这些子工程(活动),就可以导致整个工程的完成.
    //  - 表示方法 AOV网和AOE网
    // AOV网:
    //   用一个有向图表示一个工程的各个子工程及其相互制约的关系,其中以顶点表示活动,弧表示活动之间的优先制
    // 约关系,称这种有向图为顶点表示活动的网,简称AOV网(Activity On Vertex network)
    // AOE网:
    //
    //          C
    //        ↗ ↘
    //  A -> B ->  E -> F
    //        ↘ ↗
    //          D
    // AOV网必须是一个有向无环图,因为有向有环图形成环会循环依赖
    // ◼ 前驱活动：有向边起点的活动称为终点的前驱活动
    //     只有当一个活动的前驱全部都完成后，这个活动才能进行
    // ◼ 后继活动：有向边终点的活动称为起点的后继活动

    // ◼ 什么是拓扑排序？
    //    将 AOV 网中所有活动排成一个序列，使得每个活动的前驱活动都排在该活动的前面
    //    比如上图的拓扑排序结果是： A、B、C、D、E、F 或者 A、B、D、C、E、F (结果并不一定是唯一)
    //   排完的序列恰好能够挨个顺序执行完

    // 拓扑排序-思路
    //◼ 可以使用卡恩算法(Kahn于1962年提出)完成拓扑排序
    //假设 L 是存放拓扑排序结果的列表
    //  1.把所有入度为0的顶点放入L中，然后把这些顶点从图中去掉(不可持续,需要变通)
    //  2.重复操作1，直到找不到入度为0的顶点
    //   - 如果此时L中的元素个数和顶点总数相同，说明拓扑排序完成
    //   - 如果此时 L 中的元素个数少于顶点总数，说明原图中存在环，无法进行拓扑排序


    List<V> topologicalSort();

    void addEdge(V from, V to);             // 添加边

    void addEdge(V from, V to, E weight);   // 添加边带权值

    void removeEdge(V from, V to);          // 删除边

    void removeVertex(V v);                 // 删除顶点

    int edgesSize();                        // 边数量

    int verticesSize();                     // 顶点数量
}
