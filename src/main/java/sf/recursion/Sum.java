package sf.recursion;

import org.junit.Test;




public class Sum {


    // 求和
    @Test
    public void test1() {
        // 1+2+3+4+5....+(n-1)+n
        // 倒过来看: n+(n-1)+....+5+4+3+2+1 => n sum(n-1)
        System.out.println(sum(10));
    }

    /**
     * 总消耗时间T(n) = T(n-1) + O(1), 因此
     * 时间复杂度 O(n)
     * 空间复杂度 O(n)
     *
     * @param n 1..n的和
     * @return 和
     */
    private int sum(int n) {
        if (n <= 1) return 1; // 达到n <= 1条件不执行
        return n + sum(n - 1);
    }

    /**
     * 能用while来优化就用while
     * 时间复杂度 O(n)
     * 空间复杂度 O(1)
     */
    private int sum2(int n) {
        int result = 0;
        for (int i = 1; i <= n; i++) {
            result += i;
        }
        return result;
    }

    /**
     * 能用使用公式就使用公式
     * 时间复杂度 O(1)
     * 空间复杂度 O(1)
     */
    private int sum3(int n) {
        if (n <= 1) return n;
        return (1 + n) * n >> 1;
    }


    // 跳台阶

    // 汉诺塔

    //


}
// 递归: 函数(方法)直接或间接调用自身.是一种常用的编程技巧,严格来说不算是一种算法
//   1.调用一次方法,分配一段栈空间,局部变量每段栈空间独享,改变局部变量值后,传入到下一个栈空间中,直至条件不满足陆续弹出回收栈空间
//   2.如果递归调用没有终止,将会一直消耗栈空间: 最终导致栈内存溢出(Stack Overflow)
//     所以必需要有一个明确的结束递归条件,也叫做边界条件/递归基
//   3.调用至递归结束条件,逐层返回结果
//
// 注意:使用递归不是为了求得最优解,是为了简化解决问题的思路,代码会更加简洁
// 递归求出来的很有可能不是最优解,也有可能是最优解

// 递归基本思想:
// 1.拆解问题:
//   把规模大的问题变成规模较小的同类型问题
//   规模较小的问题又不断变成规模更小的问题
//   规模小到一定程度可以直接得出它的解
// 2.求解
//    由最小规模问题的解得出较大规模的解
//    由较大规模问题的解不断得出规模更大问题的解
//    最后得出原来问题的解
// 3.凡是可以利用上述思想解决问题的,都可以尝试使用递归
// -- 很多链表、二叉树相关的问题都可以使用递归来解决
// --因为链表、二叉树本身就是递归的结构(链表中包含链表,二叉树中包含二叉树)
//
// 递归的使用套路
// 1.明确函数的功能
//  -- 先不要去思考里面代码怎么写,首先搞清楚这个函数干嘛用的,能完成什么功能? -- sum()用来求1+2+3....n的值
// 2.明确原问题与子问题的关系
//   -- 寻找f(n)与f(n-1)的关系[不一定是f(n-1),次数指的是更小规模的问题]                -- sum(n) = n+sum(n-1)
// 3.明确递归基(边界条件)
//  -- 递归的过程中,子问题的规模在不断减小,当小到一定程度时可以直接得出它的解
//  -- 寻找递归基,相对于是思考:问题规模小到什么程度可以直接得出解?           -- 3?2?1? 条件到1=>如果小于等于1停止
//