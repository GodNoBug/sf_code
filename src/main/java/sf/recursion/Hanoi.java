package sf.recursion;

import org.junit.Test;

public class Hanoi {
    // 汉诺塔的解题思路
    // 有 A B C 柱, A柱的所有盘子结果某些步骤,全部移动到C柱上
    // 三条规则:
    // 1.每次只能移动一个盘子
    // 2.盘子只能在三根柱子上来回移动
    // 3,大盘在下,小盘在上

    // 有三个柱子,A,B,C
    // 编程实现把A的n个盘子移动到C(盘子编号是[1,n])
    // 1个盘子, 把1从A->C
    // 2个盘子, 把1从A->B,把2从A->C,把1从B->C
    // 3个盘子, 把1从A->C,把2从A->B,把1从C->B,把1从B->A,把2从B->C,把1从A->C
    // N个盘子, 经过一定的步骤到达C A->......->C


    // 思路:
    // 其实分2中情况讨论即可
    // 1.当n==1时,直接将盘子从A移动到C
    // 2.当n>1时,可以拆分成3大步骤(把n-1看成是一个整体)
    //   - 先将n-1个盘子从A挪动到B
    //   - 将编号为n的盘子从A移动到C
    //   - 将n-1个盘子(经过相同步骤)从B移动到C
    //   步骤1,3明显是递归调用


    // A柱(起始点),B柱(中间站),C柱(终点)
    // 假设有3块
    // 能不能把前2块当成整体,可以经过某些步骤到B,好让A移动到C,剩下的2块经过某些步骤从B移动到C
    // 那么怎么把前2块移动到B上呢?这又变成了刚才的子问题
    //
    // 而剩下的2块所在的
    @Test
    public void test1() {

    }

    /**
     * 将 n个碟子从 p1挪动到p3
     * @param p2 中间的盘子
     */
    public void hanoi(int n,String p1,String p2,String p3){

    }
}
