package sf.sort.sort.cmp.merge;
// 冯诺依曼首次提出
// 思路: 序列一份为二,对于划分出来的两个子序列递归排序,而当两个子序列已经分别有序之后,合并有序子序列
// 执行流程
// 1.不断地将当前序列平均分割成2个子序列
//   找到不能在分割(序列只剩1个元素)
// 2.不断地将2个子序列合并成一个有序序列
//   直到最终只剩下1个有序序列

// 核心是将已经将有序的序列合并成一个更大的序列
// O(nlogn)

import org.junit.Test;
// 摆法6165fc smtb 1861 4 12 fnjy tnxz
import java.util.Arrays;
@SuppressWarnings("all")
public class MergeSort {
    private int[] leftArray;

    @Test
    public void sort() {

        int[] ints = {4, 9, 8, 2, 7, 1, 3, 5, 6};
        leftArray = new int[ints.length >> 1];
        // [0,array.length)
        // [0,mid=array.length>>1)
        // [mid,array.length)
        mergeSort(0, ints.length, ints);
        System.out.println(Arrays.toString(ints));
    }

    /**
     * 归并排序
     * 对[begin,end) 范围的数据进行归并排序,提出范围参数有利于切割
     * 0  6(arr.length) 3(mid)
     * [0 3) [3,6)
     */
    private void mergeSort(int begin, int end, int[] arr) {
        if (end - begin < 2) return; // 单元素区间自然有序,否则...  end-begin 元素个数只有一个或者没有则返回
        int mid = (begin + end) >> 1;  // 以中点为界
        mergeSort(begin, mid, arr); // 对左边进行归并排序
        mergeSort(mid, end, arr);   // 对右边进行归并排序
        merge(begin, mid, end, arr); // 合并
    }

    // 将[begin,mid)和[mid,end)范围的序列合并成一个有序的序列
    // 在理解分治算法的前提下,需要有两个顺序表或链表合并成一个的基础!
    //   ai        ri           re  (i是index简称,e是end简称,r是right,l是left)
    //   ↓          ↓           ↓
    // | 8 10 12 14 3 6 11 18 |
    //  li           le
    //   ↓           ↓
    // | 8 10 12 14|    leftArray[备份左边数组]  array (ai代表覆盖到哪个单位了)
    private void merge(int begin, int mid, int end, int[] arr) {
        int li = 0, le = mid - begin;
        int ri = mid, re = end;
        int ai = begin;
        // 备份左边数组
        for (int i = li; i < le; i++) {
            leftArray[i] = arr[begin + i];
        }
        while (li < le) { // 意味着左边还没有结束,左边结束了就不用循环下去
            // 考虑等于问题
            if (ri < re && arr[ri] < leftArray[li]) {
                arr[ai] = arr[ri];
                ai++;
                ri++;
            } else { // 不必担心leftArray[li]==arr[ri]的情况会少覆盖一个值,因为先拿右边的值覆盖,后拿左边的值覆盖
                // 可以简化ai++合并进去
                arr[ai] = leftArray[li];
                ai++;
                li++;
            }
        }
    }

    // 这是两个数组合并成一个数组排序的操作.[建立在三个独立的数组的,仅作为参考.如果在同一数组相临合并需要变通]
    // |34|48|60|80|  |12|26|48*|75|
    //  ↓                  ↓
    // |34|48|60|80|  |  |26|48*|75| --->  | 12 | | | | | | | |
    // 比较两个指针谁小,就拿谁放到新数组中,然后该指针往后移
    // 再次比较,哪个小,就取元素到新数组中.
    //  ↓                     ↓
    // |34|48|60|80|  |  |  |48*|75| --->  | 12 | 26 | | | | | | |
    //     ↓                  ↓
    // |  |48|60|80|  |  |  |48*|75| --->  | 12 | 26 | 34 | | | | | |
    //        ↓               ↓
    // |  |  |60|80|  |  |  |48*|75| --->  | 12 | 26 | 34 | 48 | | | | |
    //        ↓                  ↓
    // |  |  |60|80|  |  |  |   |75| --->  | 12 | 26 | 34 | 48 | 48* | | | |
    //           ↓               ↓
    // |  |  |  |80|  |  |  |   |75| --->  | 12 | 26 | 34 | 48 | 48* | 60 | | |
    //           ↓                  ↓
    // |  |  |  |80|  |  |  |   |  | --->  | 12 | 26 | 34 | 48 | 48* | 60 | 75 | |
    //           ↓                  ↓
    // |  |  |  |  |  |  |  |   |  | --->  | 12 | 26 | 34 | 48 | 48* | 60 | 75 | 80 |
}

// 总体思路
//                | 8 7 6 5 4 3 2 1 |
//                  /              \
//         | 8 7 6 5 |            | 4 3 2 1 |
//          /       \              /       \
//     | 8 7 |     | 6 5 |     | 4 3 |    | 2 1 |      分割(divide)
//      /   \       /   \       /   \      /   \
//   | 8 | | 7 | | 6 | | 5 | | 4 | | 3 | | 2 | | 1 |   不需要分解了,因为各自有序,接下来合并
//      \   /      \    /      \    /       \   /
//     | 7 8 |     | 5 6 |     | 3 4 |     | 1 2 |     合并(merge)
//          \       /               \      /
//         | 5 6 7 8 |            | 1 2 3 4 |
//                 \                /
//                | 1 2 3 4 5 6 7 8 |

// merge思路
//   ↓              ↓
// | 3 6 11 18 |  | 8 10 12 14 |  ||
// [] 代表已经比较过了, {}代表谁比较小,()代表覆盖了
// | {3} 6 11 18 |          | 8 10 12 14 |          | 3 |
// | [3] {6} 11 18 |        | 8 10 12 14 |          | 3 6 |
// | [3] [6] 11 18 |        | {8} 10 12 14 |        | 3 6 8 |
// | [3] [6] 11 18 |        | [8] {10} 12 14 |      | 3 6 8 10 |
// | [3] [6] {11} 18 |      | [8] [10] 12 14 |      | 3 6 8 10 11 |
// | [3] [6] [11] 18 |      | [8] [10] {12} 14 |    | 3 6 8 10 11 12|
// | [3] [6] [11] 18 |      | [8] [10] [12] {14} |  | 3 6 8 10 11 12 14|
// | [3] [6] [11] {18} |    | [8] [10] [12] [14] |  | 3 6 8 10 11 12 14 18|

// TODO 在一个数组内合并两个区域(变通做法)
// 大家都从头开始,各自拿出来比较,谁比较小,取出来放进数组,指针往后挪++,以此类推
// 这是建立在三个独立的数组基础上的,而需要merge的2组序列存在于同一数组中,并且是挨在一起的需要另一种思路:
// begin        mid        end (注意位置)
//   ↓          ↓           ↓
// | 8 10 12 14 3 6 11 18 |
// 为了更好的完成merge操作,最好将器重一组序列备份出来,比如[begin,mid)
//             ri           re  (i是index简称,e是end简称,r是right,l是left)
//              ↓           ↓
// | 8 10 12 14 3 6 11 18 |
//  li           le
//   ↓           ↓
// | 8 10 12 14|    leftArray[备份左边数组]
// 然后再考虑合并,可以仔细思考一下,如果左边填满,即使全部是用备份的序列填上去的,也不影响右边,即使全部是右边的序列,也不影响备份序列.
// li==0,le==mid-begin
// ri==mid,re==end

// 实例
//        leftArray       array (ai代表覆盖到哪个单位了)
// li=0  | 3 6 11 18    |  ai =0 | 3 6 11 18 8 10 12 14 | ri==4
// li=1  |{3}6 11 18    |  ai =1 |(3)6 11 18 8 10 12 14 | ri==4
// li=2  |[3]{6}11 18   |  ai =2 |(3)(6) 11 18 8 10 12 14 | ri==4
// li=2  |[3][6]11 18   |  ai =3 |(3)(6)(8) 18{8}10 12 14  | ri==5
// li=2  |[3][6]11 18   |  ai =4 |(3)(6)(8)(10)[8]{10}12 14 | ri==6
// li=3  |[3][6]{11}18  |  ai =5 |(3)(6)(8)(10)(11)[10]12 14 | ri==6
// li=3  |[3][6][11]18  |  ai =6 |(3)(6)(8)(10)(11)(12){12} 14 | ri==7
// li=3  |[3][6][11]18  |  ai =7 |(3)(6)(8)(10)(11)(12)(14){14}| ri==8  意味着越界,无元素可以取,意味着可以直接在左边剩下的东西搬过来就可以了(右边所有比较小的元素已经没了,剩下的是绝对比较大的)
// li=4  |[3][6][11]{18}|        |(3)(6)(8)(10)(11)(12)(14)(18)|

// 归并排序merge-左边先结束
// li=0  | 3 6 9 11     |  ai =0 | 3 6 9 11 8 10 12 14 | ri==4
// li=1  |{3}6 9 11     |  ai =1 |(3)6 9 11 8 10 12 14 | ri==4
// li=2  |[3]{6} 9 11   |  ai =2 |(3)(6) 9 11 8 10 12 14 | ri==4
// li=2  |[3][6] 9 11   |  ai =3 |(3)(6)(8)11 {8}10 12 14 | ri==5
// li=3  |[3][6]{9}11   |  ai =4 |(3)(6)(8)(9)[8] 10 12 14 | ri==5
// li=3  |[3][6][9]11   |  ai =5 |(3)(6)(9)(11)(10){10} 12 14 | ri==6
// li=4  |[3][6][9]{11} |  ai =6 |(3)(6)(9)(11)(10)(11) 12 14 | ri==6  左边提前结束,整个归并就可以结束了.可以这样理解.进行比对的前提是左边还没结束


// 归并排序merge-右边先结束
// li=0  | 3 6 9 11     |  ai =0 | 3 6 9 11 1 2 4 5 | ri==4
// li=0  | 3 6 9 11     |  ai =1 |(1)6 9 11 {1} 2 4 5 | ri==5
// li=0  | 3 6 9 11     |  ai =2 |(1)(2) 9 11 [1]{2}4 5 | ri==6
// li=1  |[3]6 9 11     |  ai =3 |(1)(2)(3)11 [1][2]4 5 | ri==6
// li=1  |[3]6 9 11     |  ai =4 |(1)(2)(3)(4)[1][2]{4} 5 | ri==7
// li=1  |[3]6 9 11     |  ai =5 |(1)(2)(3)(4)(5)[2][4]{5}| ri==8
// li=2  |[3]{6}9 11    |  ai =6 |(1)(2)(3)(4)(5)(6)[4][5]| ri==8
// li=3  |[3][6]{9}11   |  ai =7 |(1)(2)(3)(4)(5)(6)(9)[5]| ri==8
// li=2  |[3][6][9]{11} |  ai =8 |(1)(2)(3)(4)(5)(6)(9)(11)| ri==8

// 归并排序花费的时间
// T(n)=2*T(n/2)+O(n)
// T(1)=O(1)
// T(n)/n =T(n/2)/(n/2)+O(1)

// 令S(n) =T(n)/n
// S(1) =O(1)
// S(n) =S(n/2)+O(1) =S(n/4)+O(2)=S(n/8)+O(3)=S(n/2^k)+O(k) =S(1)+O(logn)=O(logn)
// T(n)=n*S(n) =O(nlogn)
// 由于归并排序总是平均分割子序列,所以最好/最坏/平均时间复杂度都是O(nlogn).属于稳定排序
// 从代码中不难看出: 归并排序的空间复杂度是O(n/2 + logn) =O(n) n/2用于临时存放左侧数组,logn是因为递归调用
//
// 常见的递推式与复杂度
// |递推式             |复杂度     |
// |T(n)=T(n/2)+O(1)  | O(logn)   |
// |T(n)=T(n-1)+O(1)  | O(n)      |
// |T(n)=T(n/2)+O(n)  | O(n)      |
// |T(n)=2T(n/2)+O(1) | O(n)      |
// |T(n)=2T(n/2)+O(n) | O(nlogn)  |
// |T(n)=T(n-1)+O(n)  | O(n^2)    |
// |T(n)=2T(n-1)+O(1) | O(2^n)    |
// |T(n)=2T(n-1)+O(n) | O(2^n)    |

// 作业
//  合并两个有序数组
//  https://leetcode-cn.com/problems/merge-sorted-array/
//  合并两个有序链表
//  https://leetcode-cn.com/problems/merge-two-sorted-lists/comments/
//  合并K个有序链表
//  https://leetcode-cn.com/problems/merge-k-sorted-lists/

// 休眠排序

